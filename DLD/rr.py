# -*- coding: utf-8 -*-
"""DLD_Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    C
"""

import pandas as pd
import numpy as np
import re

# clean_string removes all the characters except numbers and comma,
# it also removes leading, trailing, repetative comma, and space.
def clean_string(input_string):
    # Remove all characters except numbers and commas
    cleaned_string = re.sub(r'[^0-9,]', '', input_string)

    # Replace multiple commas with just one comma
    cleaned_string = re.sub(r',{2,}', ',', cleaned_string)

    # Remove commas from the beginning and end of the string
    cleaned_string = cleaned_string.strip(',')

    # Ensure the string starts and ends with a number
    """ if cleaned_string and not cleaned_string[0].isdigit():
        cleaned_string = '0' + cleaned_string
    if cleaned_string and not cleaned_string[-1].isdigit():
        cleaned_string += '0' """

    return cleaned_string

# fillgroup is a function which gives out the number of 1's
# present in the binary representation of the input n
def fillgroup(n):
  binrep = bin(n)[2:]
  group = 0
  for i in range(len(binrep)):
    group = group + int(binrep[i])
  return str(group)


# fillgroup is a function which gives out the
# combination of the minterms
def fillcombo(n):
  return str(n)


# fillgroup is a function which gives out the
# binary representation of the input n
def fillbinrep(n):
  binrep = bin(n)[2:]
  binrep = str(binrep)
  binrep = binrep.rjust((num_var - len(binrep)) + len(binrep), '0')
  return binrep


# creat_string is a function which takes two string of same length
# compare them character wise, and if there is one character difference
# it gives a new sting, else returns 0
def create_string(s1, s2):
  c=0
  s3=''
  for i in range(len(s1)):
        if s1[i] == s2[i]:
            s3 += s1[i]
        else:
            s3 += '2'
            c= c+1
  if c==1:
      return s3
  else:
      return 0



# exgen is a expression generator function, which generates
# minterm for given binary number, i.e. input n
def exgen(s):
  c = ''
  for i in range(len(s)):
      if s[i]=='1':
          c = c + 'a' + str(i) + ' '
      elif s[i]=='0':
          c = c + 'a' + str(i) + '_' + ' '
      #else :
       #   z = 0
  return c

print('please provide your input with SoP implicants in comma seperated format')
List = input()
List = clean_string(List)
# List = ''.join(List.split()) #removes space from the string List
print("\nGiven input is:", List)
print("\n")
List = List.split(",") # convets 'List' from string to list
List = [eval(i) for i in List]  #changing str datatype to int in the list

List.sort() #sorting the list

response = input("Do you know the number of variables for your equation?\nType y for 'yes' and n for 'no': ")
print("\n")
if response == "y":
  num_var=input("What is the number of variable in your input: ")
  num_var = int(num_var)
elif response == "n":
  num_var = 1 # finding the number of varibles in the expression
  while (not(List[-1] <= ((2**num_var)-1))):
    num_var = num_var+1
  print("The least number of variable based on your input is:", num_var)
else:
  num_var = 1 # finding the number of varibles in the expression
  while (not(List[-1] <= ((2**num_var)-1))):
    num_var = num_var+1
  print("Your responce is not in prescribed format. The least number of variable based on your input is:", num_var)



print("\nNumber of variable in the expression is:" + str(num_var) + ", from a0 to a" + str(num_var - 1))

# creating a dataframe df4 with columns as 'Group','Combo','Binrep'
df4 = pd.DataFrame(columns=['Group','Combo','Binrep'])

for  i in List: # populating the df4 dataframe according to the List
  df4.loc[len(df4.index)] = [ fillgroup(i) , fillcombo(i) , fillbinrep(i) ]

# sorting df4 by 'Group' column, preserving the row indice
df4 = df4.sort_values(by='Group').reset_index(drop=True)

# creating dataframe df5 and df6 with column names as 'Group','Combo','Binrep'
df5 = pd.DataFrame(columns=['Group','Combo','Binrep'])
df6 = pd.DataFrame(columns=['Group','Combo','Binrep'])
df6=df4

# comparing the single bit parity in df4 'Binrap', and modifying df5 and df6
# accordingly in a loop, until no further simplification is possible
while (1):
    new_list = df4['Group'].tolist()

    new_dict = {}
    for num in new_list:
        if num in new_dict:
            new_dict[num] += 1
        else:
            new_dict[num] = 1
    list3 = list(new_dict.keys())



    for i in range(len(list3)-1):
        if i==0:
            p1=0
            p2= p1 + new_dict[list3[i]]
        else:
            p1=p2
            p2= p1 + new_dict[list3[i]]
        for j in range(new_dict[list3[i]]):
            for k in range(new_dict[list3[i+1]]):
                if create_string(df4['Binrep'].iloc[p1+j], df4['Binrep'].iloc[p2+k]) == 0 :
                    z=0
                else :
                    df5.loc[len(df5.index)] = [ df4['Group'].iloc[p1+j] , df4['Combo'].iloc[p1+j]
                                               + ","+ df4['Combo'].iloc[p2+k] ,
                                                create_string(df4['Binrep'].iloc[p1+j],
                                                              df4['Binrep'].iloc[p2+k])]
                    df6 = df6.drop(df6[df6['Binrep'] == df4['Binrep'].iloc[p1+j]].index)
                    df6 = df6.drop(df6[df6['Binrep'] == df4['Binrep'].iloc[p2+k]].index)

    df6 = pd.concat([df6, df5], axis=0)
    df4 = df5
    df5 = df5[0:0]
    if len(df4) == 0:
        break

#extracting a column named 'Binrep' from a DataFrame df6 and converting it into a list.
final_list = df6['Binrep'].tolist()
final_list

#removing duplicate elements from the list final_list.
final_list = list(set(final_list))
final_list

# Creating the Sum of Product (SoP) for the final df6
Expression = ''
for i in final_list:

    Expression = Expression + str(exgen(i)) + '+ '

Expression = Expression[:-3]
print("The non minimised expression is:", Expression)

# creating a minimised expression by removing non essential prime implicants
k=''
for i in final_list:

  k = k + df6.loc[df6['Binrep'] == i, 'Combo'].iloc[0] + ','

k = k[:-1]

#converting 'my_list' string data type into a list data type
my_list = k.split(",")

# creating a dictionary 'my_dict' whose keys are unique items present in
# 'my_list' are values are the frequency of that item(key)
my_dict = {}
for num in my_list:
        if num in my_dict:
            my_dict[num] += 1
        else:
            my_dict[num] = 1

# creating a list corrosponding to essential prime implicants only
last_list = []
for i in final_list:
  m = df6.loc[df6['Binrep'] == i, 'Combo'].iloc[0]
  m_list = m.split(",")
  for j in m_list:
    if my_dict[j] == 1:
      last_list.append(i)
      break

# Generating minimised expression from essential prime implicants
Minisised_expression = ''
for i in last_list:
    Minisised_expression = Minisised_expression + str(exgen(i)) + '+ '
Minisised_expression = Minisised_expression[:-3]
if len(Minisised_expression) == 0:
  print("Your expression results to a constant, either 0 or 1")
else:
  print("The minimised expression is:", Minisised_expression)


# when all m's are 0, it gives out empty expression

